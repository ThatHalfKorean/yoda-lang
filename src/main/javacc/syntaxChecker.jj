PARSER_BEGIN(Parser)

package edu.lmu.cs.xlg.yoda.syntax;

import java.util.List;
import java.util.ArrayList;
import java.io.Reader;
import edu.lmu.cs.xlg.util.Log;
import edu.lmu.cs.xlg.yoda.entities.*;

public class Parser {
    /**
     * Returns the result of parsing the Yoda program on the given Reader.
     */
    public Script parse(Log log) {
        try {
            return SCRIPT();
        } catch (TokenMgrError e) {
            log.exception(e);
            return null;
        } catch (ParseException e) {
            log.exception(e);
            return null;
        }
    }
}

PARSER_END(Parser)

SKIP: { " " | "\t"
    | <"<(-_-)>" (~["\n","\r"])* ("\n"|"\r")>
}

SKIP : {
    "<(-.-)>" : WithinComment
}

<WithinComment> SKIP :
{
    "<(-.-)>" : DEFAULT
}

<WithinComment> MORE :
{
    <~[]>
}

TOKEN: {
    "(" | ")" | "{" | "}" | "+" | "*" | ":=" | "|" | "&" | "," | ":" | "."
    | <IF: ("if")>
    | <TO: ("to")>
    | <BY: ("by")>
    | <AND: ("and")>
    | <PERHAPS: ("perhaps")>
    | <HMM: ("hmm")>
    | <HMMQ: ("hmm?")>
    | <IS: ("is?")>
    | <ELSE: ("else")>
    | <FROM: ("from")>
    | <DOES: ("does")>
    | <RUNS: ("runs")>
    | <WHILE: ("while")>
    | <BEGIN: ("begin")>
    | <BEGINS: ("begins")>
    | <GIVEN: ("given")>
    | <GIVES: ("gives")>
    | <GET: ("get")>
    | <TIMES: ("times")>
    | <BECOME: ("become")>
    | <BECOMES: ("becomes")>
    | <NOTHING: ("nothing")>
    | <THROUGH: ("through")>
    | <AS: ("as")>
    | <TRAINING: ("training")>
    | <MUST: ("must")>
    | <BE: ("be")>
    | <YOU: ("you")>
    | <PRINT: ("print")>
    | <GIVEBACK: ("give back")>
    | <ON: ("on")>
    | <ID: ((["a"-"z"] | ["A"-"Z"])+(["-"] | ["_"] | ["a"-"z"] | ["A"-"Z"] | ["0"-"9"])*)>
    | <NUMLIT: (("0x" | "0b" | "0o")? (["0"-"9"])+("."(["0"-"9"])*)?)>
    | <STRLIT: ("\"" (~["\""] | ("\\\""))* "\"") >
    | <BR: ("\n" | "\r" | "\r\n" )>

}


Script SCRIPT(): {
    List<Statement> statements = new ArrayList<Statement>();
    Statement s;
}
{
    (<BR>)*
    
    s = STMT() {statements.add(s);} 
    (LOOKAHEAD((<BR>)+ STMT()) (<BR>)+ STMT() {statements.add(s);})*
    
    (<BR>)* <EOF>
    {return new Script(statements);}
}

Statement STMT(): {
    Statement s;
}
{
   ( LOOKAHEAD(BLOCK() <WHILE>) s = WHILELOOP()
   | LOOKAHEAD(BLOCK() <AS>) s = FORLOOP()
   | LOOKAHEAD(BLOCK() <IF>) s = CONDITIONAL()
   | LOOKAHEAD(BLOCK() EXP()) s = TIMESLOOP()
   | LOOKAHEAD(BLOCK() <GIVEN> PARAMS() "," <ID> <DOES>) s = PROCDEC()
   | LOOKAHEAD(BLOCK() <GIVEN> PARAMS() "," <ID> <GIVES>) s = FUNDEC()
   | LOOKAHEAD(EXP() <YOU> <PRINT>) s = PRINTSTMT()
   | LOOKAHEAD(EXP() "," <ID> <MUST> <BE>) s = CONSTDEC()
   | LOOKAHEAD(<FROM> | (EXP() (<AND> EXP())*  "," <ID> ( <AND> <ID>)* (<BEGIN> | <BEGINS>))) s = VARDEC()
   | LOOKAHEAD(EXP() (<AND> EXP())* "," <ID> ( <AND> <ID>)* (<BECOME> | <BECOMES>)) s = ASSIGNMENT()
   //| LOOKAHEAD((<ID> ".") | ("(" ARGS() ")" <ID>)) s = FUNCALL()
   | LOOKAHEAD(<GIVEBACK>) s = RETURNSTMT()
   //| LOOKAHEAD(FUNCALL()) s = PROCCALL()
   // TODO: expression is not a statement
   //| s = EXP()
   )
   {return s;}
}

DecStatement VARDEC(): {
    List<String> tokens = new ArrayList<String>();
    List<Variable> variables = new ArrayList<Variable>();
    Token t;
    List<Expression> exps = new ArrayList<Expression>();
    Expression e;
    boolean constant = false;
    boolean derived = false;
}
{
    (
      (e = EXP()) {exps.add(e);}
      (<AND> (e = EXP()) {exps.add(e);})*
      ","
      (t = <ID>) {tokens.add(t.image);}
      (<AND> (t = <ID>) {tokens.add(t.image);})*
      (<BEGIN> | <BEGINS>)
    |
      <FROM> e = EXP() {exps.add(e);}
      ","
      (t = <ID>) {tokens.add(t.image);}
      {derived = true;}
      <BEGINS>
    )

    {
      // ???: REVISIT LANGUAGE DESIGN
      for (int i = 0; i < tokens.size(); i++) {
        variables.add(new Variable(tokens.get(i),
          i < exps.size() ? exps.get(i) : null, constant, derived));
      }
      return new DecStatement(variables);
    }
}

Variable CONSTDEC(): {
    Token t;
    Expression e;
    boolean constant = true;
}
{
    ((e = EXP() ) "," (t = <ID>)  <MUST>  <BE>)
    {return new Variable(t.image, e, constant, false);}
}

Procedure PROCDEC(): {
    Token t;
    Block b;
    List<Variable> params = new ArrayList<Variable>();
}
{
    ((b = BLOCK()) <GIVEN> (PARAMS(params)) ","  (t = <ID>)  <DOES>)
    {return new Procedure(t.image, params, b);}
}

Function FUNDEC(): {
    Token t;
    Block b;
    List<Variable> params = new ArrayList<Variable>();
}
{
    ((b = BLOCK()) <GIVEN> (PARAMS(params)) ","  (t = <ID>)  <GIVES>)
    {return new Function(t.image, params, b);}
}
void PARAMS(List<Variable> params): {
    Token t;
}
{
    (<NOTHING> | (t = <ID> {params.add(new Variable(t.image, null, false, false));}
     (  <AND>  t = <ID> {params.add(new Variable(t.image, null, false, false));})*))
}

Statement ASSIGNMENT(): {
    List<String> tokens = new ArrayList<String>();
    List<Expression> targets = new ArrayList<Expression>();
    List<Expression> sources = new ArrayList<Expression>();
    Token t;
    Expression e;
    String op = null;
    IdentifierExpression i;
}
{
    (( op = INCOP() t = <ID>
    {i = new IdentifierExpression(t.image);
        e = new UnaryExpression(op, i);
        targets.add(i);
        sources.add(e);} )
    | (op = UPDATE() t = <ID> e = EXP()
    {i = new IdentifierExpression(t.image);
        targets.add(i);
        sources.add(e);})
    | (e = EXP(){sources.add(e);} (<AND> e = EXP() {sources.add(e);})*
        ","  t = <ID> {i = new IdentifierExpression(t.image);
        targets.add(i);}(  <AND> t = <ID> {targets.add(i);})*  (<BECOME> | <BECOMES>)))
    {return new AssignmentStatement(i, e);}
}

Statement PRINTSTMT(): {
    Expression e;
}
{
    (e = EXP() <YOU> <PRINT>)
    {return new PrintStatement(e);}
}

Statement RETURNSTMT(): {
    Expression e = null;
}
{
    <GIVEBACK>  e = EXP() <YOU> <MUST>
    {return new ReturnStatement(e);}
}

Statement CONDITIONAL(): {
    List<ConditionalStatement.Arm> arms = new ArrayList<ConditionalStatement.Arm>();
    Expression e;
    Block b;
    Block elseBlock = null;
}
{
    (b = BLOCK() <IF> "(" e = EXP()    {arms.add(new ConditionalStatement.Arm(e, b));} ")"
    (LOOKAHEAD((<BR>)+ <ELSE> BLOCK() <IF>) (<BR>)+ <ELSE> b = BLOCK() <IF> "(" e = EXP() ")"
    {arms.add(new ConditionalStatement.Arm(e, b));})*
    (LOOKAHEAD((<BR>)+ <ELSE>)(<BR>)+ <ELSE> elseBlock = BLOCK() )?)

    {return new ConditionalStatement(arms, elseBlock);}
}

Statement TIMESLOOP(): {
    Block b;
    Expression e;
}
{
    (b = BLOCK() e = EXP() <TIMES>)
    {return new TimesLoop(e, b);}
}

Statement FORLOOP(): {
    Block b;
    Token t;
    Expression condition = null;
    Expression step = new NumberLiteral("1");
    Range r = null;
}
{
    b = BLOCK() <AS>  <THROUGH> (LOOKAHEAD( (<NUMLIT> | <ID> | FUNCALL() ) <TO>) r = RANGE()
                                             | condition = EXP() ) (<BY> step = EXP())? t = <ID>  <RUNS>
    {
        if(condition == null) {            return new RangeLoop(new Variable(t.image), r, step, b);
        } else {
            return new ConditionalLoop(new Variable(t.image), condition, step, b);        }
    }
}

Statement WHILELOOP(): {
    Block b;
    Expression e;
}
{
    b = BLOCK() <WHILE> e = EXP()
    {return new WhileLoop(e, b);}
}

FunctionCall PROCCALL(): {
    FunctionCall f;
}
{
    f = FUNCALL()
    {return f;}
}

Block BLOCK(): {
    List<Statement> statements = new ArrayList<Statement>();
    Statement s;
}
{
    "{"
    (<BR>)*
    
    s = STMT() {statements.add(s);} 
    (LOOKAHEAD((<BR>)+ STMT()) (<BR>)+ STMT() {statements.add(s);})*
    
    (<BR>)* "}"
    {return new Block(statements);}
}

Expression EXP(): {
    String op;
    Expression e1 = null;
    Expression e2;
    List<Expression> exps = new ArrayList<Expression>();
    Expression condition;
    Token t;
}
{
   "(" (op = RELOP() e1 = EXP() e2 = EXP() <IS> {e1 = new BinaryExpression(e1, op, e2);} )
   	   | (op = ARITHOP() e1 = EXP() (e2 = EXP(){e1 = new BinaryExpression(e1, op, e2);})+ ) 
   	   | (<PERHAPS> condition = EXP() <HMMQ> e1 = EXP() <HMM> e2 = EXP() {return new TernaryExpression(condition, e1, e2);})
   	   | (op = UNARYOP() e1 = EXP() {return new UnaryExpression(op, e1);})
   	   | (<ON> ( <NOTHING> |  (e1 = EXP() {exps.add(e1);})+ ) t = <ID>
   	       {
   	       	   e2 = new IdentifierExpression(t.image);
   	           return new FunctionCall(e2, exps);
   	       })
   ")"  
   | e1 = ARRAY()
   | e1 = LIT()
   | e1 = OBJECT()
   | t = <ID> {e1 = new IdentifierExpression(t.image);}
   {return e1;}
}

Literal LIT(): {
    Token t;
}{
  t = <NUMLIT>  {return new NumberLiteral(t.image);}  |
  t = <STRLIT>
  {return new StringLiteral(t.image);}
}

ArrayConstructor ARRAY():{
    Expression e;
    List<Expression> es = new ArrayList<Expression>();}
{
    ("[" ( (<BR>)? e = EXP() {es.add(e);} ("," (<BR>)? e = EXP() {es.add(e);})* (<BR>)?)* "]")
    {return new ArrayConstructor(es);}
}
ObjectExpression OBJECT(): {
    ObjectExpression o = new ObjectExpression();
    Token t;
    Expression e = null;
    Function f = null;
}
{ "{" (<BR>)* (":" t = <ID>  e = EXP()
    ( "," (<BR>)* ":" <ID> ( EXP()))* (<BR>)* )? (<BR>)* "}" (<TO>  <BE>  <ID>)? ","  (<ID> )? <TRAINING>  <BEGINS>
    {return o;}
}

FunctionCall FUNCALL(): {
    Token functionName = null;
    List<Expression> args = new ArrayList<Expression>();
    Token objectName = null;
}
{
    <ON> (objectName = <ID>".")?"("args = ARGS()")"(functionName = <ID>)
    {
        if (objectName != null)        {            return new FunctionCall(new IdentifierExpression(objectName.image + "." + functionName.image), args);
        } else {
            return new FunctionCall(new IdentifierExpression(functionName.image), args);
        }    }
}
String RELOP(): {
    Token s;
}

{   s = "<"
    | s = "<="
    | s = "="
    | s = "!="
    | s = ">="
    | s = ">"
    {return s.image;}
}
String ARITHOP(): {
    Token s;
    String update;
}
{
    s = "*"
    | s = "/"
    | s = "+"
    | s = "-"
    | s = "%"
    | s = "^"
    | s = "|"
    | s = "&"
    {return s.image;}
}

String UNARYOP(): {
    Token t;
}
{
    t = "!"    {return t.image;}}

String INCOP(): {
    Token s;
}
{
    s = "++"
    | s = "--"
    {return s.image;}
}

String UPDATE(): {
    Token s;
}
{
    s = "+="
    | s = "-="
    {return s.image;}
}

List<Expression> ARGS(): {
    List<Expression> args = new ArrayList<Expression>();
}
{
    (ARGS1(args) ("," ARGS1(args))*)?
    {return args;}
}
void ARGS1(List<Expression> args): {
}
{
   LOOKAHEAD(BLOCK() <GIVEN> PARAMS() "," <ID> <DOES>) PROCDEC()
   | LOOKAHEAD(BLOCK() <GIVEN> PARAMS() "," <ID> <GIVES>) FUNDEC()
   | LOOKAHEAD((<ID>".")? "("ARGS()")") FUNCALL()
   | EXP()
}
Range RANGE(): {
    Expression l = null;
    Expression h = null;
    Token t;
}
{
    (t = <NUMLIT> {l = new NumberLiteral(t.image);}
    |t = <ID> {l = new IdentifierExpression(t.image);}
    | FUNCALL())
    <TO> (t = <NUMLIT> {h = new NumberLiteral(t.image);}
    | t = <ID> {h = new IdentifierExpression(t.image);}
    | FUNCALL())    {return new Range(l, h);}
}
