PARSER_BEGIN(Parser)

package edu.lmu.cs.xlg.yoda.syntax;

import java.util.List;
import java.util.ArrayList;
import java.io.Reader;
import edu.lmu.cs.xlg.util.Log;
import edu.lmu.cs.xlg.yoda.entities.*;

public class Parser {
    public static void main(String[] args) {
        try {
            new Parser(new java.io.FileReader(args[0])).SCRIPT();
            System.out.println("Syntax is okay");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: " + e.getMessage());
        }
    }
}

PARSER_END(Parser)

SKIP: { " " | "\t"
    | <"<(-_-)>" (~["\n","\r"])* ("\n"|"\r")>
}

SKIP : {
    "<(-.-)>" : WithinComment
}

<WithinComment> SKIP :
{
    "<(-.-)>" : DEFAULT
}

<WithinComment> MORE :
{
    <~[]>
}

TOKEN: {
    "(" | ")" | "{" | "}" | "+" | "*" | ":=" | "|" | "&" | "," | ":" | "."
    | <IF: ("if")>
    | <TO: ("to")>
    | <BY: ("by")>
    | <AND: ("and")>
    | <HMM: ("hmm")>
    | <HMMQ: ("hmm?")>
    | <IS: ("is?")>
    | <ELSE: ("else")>
    | <FROM: ("from")>
    | <DOES: ("does")>
    | <RUNS: ("runs")>
    | <WHILE: ("while")>
    | <BEGIN: ("begin")>
    | <BEGINS: ("begins")>
    | <GIVEN: ("given")>
    | <GIVES: ("gives")>
    | <GET: ("get")>
    | <TIMES: ("times")>
    | <BECOME: ("become")>
    | <BECOMES: ("becomes")>
    | <NOTHING: ("nothing")>
    | <THROUGH: ("through")>
    | <AS: ("as")>
    | <TRAINING: ("training")>
    | <MUST: ("must")>
    | <BE: ("be")>
    | <YOU: ("you")>
    | <PRINT: ("print")>
    | <GIVEBACK: ("give back")>
    | <ID: ((["a"-"z"] | ["A"-"Z"])+(["-"] | ["_"] | ["a"-"z"] | ["A"-"Z"] | ["0"-"9"])*)>
    | <NUMLIT: (("0x" | "0b" | "0o")? (["0"-"9"])+("."(["0"-"9"])*)?)>
    | <STRLIT: ("\"" (~["\""] | ("\\\""))* "\"") >
    | <BR: ("\n" | "\r" | "\r\n" )>

}


Script SCRIPT(): {
    List<Statement> statements = new ArrayList<Statement>();
    Statement s;
}
{
    (<BR>)*
    (s = STMT() {statements.add(s);})+
    <EOF>
    {return new Script(statements);}
}

Statement STMT(): {
    Statement s;
}
{
     (LOOKAHEAD(BLOCK() <WHILE>) s = WHILELOOP()
   | LOOKAHEAD(BLOCK() <AS>) s = FORLOOP()
   | LOOKAHEAD(BLOCK() <IF>) s = CONDITIONAL()
   | LOOKAHEAD(BLOCK() EXP()) s = TIMESLOOP()
   | LOOKAHEAD(BLOCK() <GIVEN> PARAMS() "," <ID> <DOES>) s = PROCDEC()
   | LOOKAHEAD(BLOCK() <GIVEN> PARAMS() "," <ID> <GIVES>) s = FUNDEC()
   | LOOKAHEAD(BLOCK() <GIVEN> ARGS()) s = ANONFUN()
   | LOOKAHEAD(EXP() <YOU> <PRINT>) s = PRINTSTMT()
   | LOOKAHEAD(EXP() "," <ID> <MUST> <BE>) s = CONSTDEC()
   | LOOKAHEAD(<FROM> | (EXP() (<AND> EXP())*  "," <ID> ( <AND> <ID>)* (<BEGIN> | <BEGINS>))) s = VARDEC()
   | LOOKAHEAD(EXP() (<AND> EXP())* "," <ID> ( <AND> <ID>)* (<BECOME> | <BECOMES>)) s = ASSIGNMENT()
   | LOOKAHEAD((<ID> ".") | ("(" ARGS() ")" <ID>)) s = FUNCALL()
   | LOOKAHEAD(<GIVEBACK>) s = RETURNSTMT()
   | LOOKAHEAD(FUNCALL()) s = PROCCALL()
)// TODO: expression is not a statement
   //| s = EXP())
   ((<BR>)+ | <EOF>)
   {return s;}
}

DecStatement VARDEC(): {
    List<String> tokens = new ArrayList<String>();
    List<Variable> variables = new ArrayList<Variable>();
    Token t;
    List<Expression> exps = new ArrayList<Expression>();
    Expression e;
    boolean constant = false;
}
{
    ((e = EXP() ){exps.add(e);} (<AND> (e = EXP()) {exps.add(e);} )* "," (t = <ID>) {tokens.add(t.image);}
        ( <AND>  (t = <ID>) {tokens.add(t.image);})*  (<BEGIN> | <BEGINS>))
        | (<FROM> EXP() "," (t = <ID>) {tokens.add(t.image);}  <BEGINS>)
    // TODO: Must account for multiple declarations.
    {for(int i = 0; i < tokens.size(); i++){
        variables.add(new Variable(tokens.get(i), exps.get(i), constant));
    }
    return new DecStatement(variables);}
}

Variable CONSTDEC(): {
    Token t;
    Expression e;
    boolean constant = true;
}
{
    ((e = EXP() ) "," (t = <ID>)  <MUST>  <BE>)
    {return new Variable(t.image, e, constant);}
}

Procedure PROCDEC(): {
    Token t;
    Block b;
    List<Variable> params = new ArrayList<Variable>();
}
{
    ((b = BLOCK()) <GIVEN> (PARAMS(params)) ","  (t = <ID>)  <DOES>)
    {return new Procedure(t.image, params, b);}
}

Function FUNDEC(): {
    Token t;
    Block b;
    List<Variable> params = new ArrayList<Variable>();
}
{
    ((b = BLOCK()) <GIVEN> (PARAMS(params)) ","  (t = <ID>)  <GIVES>)
    {return new Function(t.image, params, b);}
}
void PARAMS(List<Variable> params): {
    Token t;
}
{
    (<NOTHING> | (t = <ID> {params.add(new Variable(t.image, null, false));}
     (  <AND>  t = <ID> {params.add(new Variable(t.image, null, false));})*))
}

Statement ASSIGNMENT(): {
    List<String> tokens = new ArrayList<String>();
    List<Expression> targets = new ArrayList<Expression>();
    List<Expression> sources = new ArrayList<Expression>();
    Token t;
    Expression e;
    String op = null;
    IdentifierExpression i;
}
{
    (( op = INCOP() t = <ID>
    {i = new IdentifierExpression(t.image);
        e = new UnaryExpression(op, i);
        targets.add(i);
        sources.add(e);} )
    | (op = UPDATE() t = <ID> e = EXP5()
    {i = new IdentifierExpression(t.image);
        targets.add(i);
        sources.add(e);})
    | (e = EXP(){sources.add(e);} (<AND> e = EXP() {sources.add(e);})*
        ","  t = <ID> {i = new IdentifierExpression(t.image);
        targets.add(i);}(  <AND> t = <ID> {targets.add(i);})*  (<BECOME> | <BECOMES>)))
    {return new AssignmentStatement(i, e);}
}

Statement PRINTSTMT(): {
    Expression e;
}
{
    (e = EXP() <YOU> <PRINT>)
    {return new PrintStatement(e);}
}

Statement RETURNSTMT(): {
    Expression e;
    Function f;
}
{
    (<GIVEBACK> ( f = ANONFUN() | e = EXP()) <YOU>  <MUST>)
    {if(f == null){
        return new ReturnStatement(e);
    }else
        return f;
    }
}

Statement CONDITIONAL(): {
    List<ConditionalStatement.Arm> arms = new ArrayList<ConditionalStatement.Arm>();
    Expression e;
    Block b;
    Block elseBlock = null;
}
{
    (b = BLOCK() <IF> "(" e = EXP()    {arms.add(new ConditionalStatement.Arm(e, b));} ")"
    (LOOKAHEAD((<BR>)+ <ELSE> BLOCK() <IF>) (<BR>)+ <ELSE> b = BLOCK() <IF> "(" e = EXP() ")"
    {arms.add(new ConditionalStatement.Arm(e, b));})*
    (LOOKAHEAD((<BR>)+ <ELSE>)(<BR>)+ <ELSE> elseBlock = BLOCK() )?)

    {return new ConditionalStatement(arms, elseBlock);}
}

Statement TIMESLOOP(): {
    Block b;
    Expression e;
}
{
    (b = BLOCK() e = EXP() <TIMES>)
    {return new TimesLoop(e, b);}
}

Statement FORLOOP(): {
    Block b;
    Expression e;
    Range r;
}
{
    b = BLOCK() <AS>  <THROUGH> (LOOKAHEAD( (<NUMLIT> | <ID> | FUNCALL() ) <TO>) r = RANGE()
                                             | e = EXP5() ) (<BY> e = EXP5())? <ID>  <RUNS>
    {return new RangeLoop(r, e, b);}
}

Statement WHILELOOP(): {
    Block b;
    Expression e;
}
{
    b = BLOCK() <WHILE> e = EXP()
    {return new WhileLoop(e, b);}
}

Statement PROCCALL(): {
    Statement s;
}
{
    s = FUNCALL()
    {return s;}
}

Block BLOCK(): {
    List<Statement> statements = new ArrayList<Statement>();
    Statement s;
}
{
    ("{" (<BR>)* (s = STMT() {statements.add(s);})
        ((<BR>)+ (s = STMT(){statements.add(s);})?)* (<BR>)*"}")
    {return new Block(statements);}
}

Expression EXP(): {
    Expression e1;
    Expression e2;
}
{
    e1 =  EXP1() ("|" e2 = EXP1(){e1 = new BinaryExpression(e1, "|", e2);} )*
    {return e1;}
}
Expression EXP1(): {
    Expression e1;
    Expression e2;
}
{
    e1 = EXP2() ("&" e2 = EXP2() {e1 = new BinaryExpression(e1, "&", e2);})*
    {return e1;}
}
Expression EXP2(): {
    String op;
    Expression e1;
    Expression e2;
}
{
    (op = RELOP() e1 = EXP3() e2 = EXP3() <IS> {e1 = new BinaryExpression(e1, op, e2);} )
   | (op = ARITHOP() e1 = EXP3() (e2 = EXP3(){e1 = new BinaryExpression(e1, op, e2);})+ )
   | e1 = EXP3()
   {return e1;}
}

Expression EXP3(): {
    String op = null;
    Expression e;
}
{
    (op = UNARYOP()  e = EXP4() )  | e = EXP4()
    {return op == null ? e : new UnaryExpression(op, e);}
}
Expression EXP4(): {
    Expression e1;
    Expression e2;
    Expression e3;
}
{
    ( EXP5() (<HMMQ> (EXP5() | ASSIGNMENT()) <HMM> (EXP5() | ASSIGNMENT()) )?)
}
Expression EXP5(): {} { ARRAY()
   | LIT()
   | LOOKAHEAD("{" (<BR>)* (":" | "}")) OBJECT()
   | LOOKAHEAD((<ID> ".")? "("ARGS()")") FUNCALL()
   | <ID>
   | "(" EXP() ")"}
Literal LIT(): {
    Literal l;
}
{
    l = <NUMLIT> | l = <STRLIT>
    {return l;}
}
void ARRAY(): {} { ("[" ( (<BR>)? EXP() ("," (<BR>)? EXP())* (<BR>)?)* "]") }
void OBJECT(): {} { "{" (<BR>)* (":" <ID> ( FUNDEC() | EXP5()) ( "," (<BR>)* ":" <ID> (FUNDEC() | EXP5()))* (<BR>)* )? (<BR>)* "}" (<TO>  <BE>  <ID>)? ","  (<ID> )? <TRAINING>  <BEGINS> }
Function ANONFUN(): {} { BLOCK() <GIVEN> PARAMS() }
Statement FUNCALL(): {} { (<ID>".")?"("ARGS()")"(<ID> | ANONFUN()) }
String RELOP(): {} { "<" | "<=" | "=" | "!=" | ">=" | ">" }
String ARITHOP(): {} { "*" | "/" | "+" | "-" | "%" | "^" | UPDATE() }
String UNARYOP(): {} { "!" }
String INCOP(): {} { "++" | "--" }
String UPDATE(): {} { "+=" | "-="}

void ARGS(): {} { (ARGS1() ("," ARGS1())*)? }
void ARGS1(): {} { LOOKAHEAD(BLOCK() <GIVEN> PARAMS() "," <ID> <DOES>) PROCDEC()
   | LOOKAHEAD(BLOCK() <GIVEN> PARAMS() "," <ID> <GIVES>) FUNDEC()
   | LOOKAHEAD(BLOCK() <GIVEN> PARAMS()) ANONFUN()
   | LOOKAHEAD((<ID>".")? "("ARGS()")") FUNCALL()
   | EXP5() }
Range RANGE(): {
    Expression l;
    Expression h;
    Token t;
}
{
    (l = <NUMLIT> | l = <ID> | l = FUNCALL()) <TO> (h = <NUMLIT> | h = <ID> | h = FUNCALL())    {return new Range(l, h);}
}
