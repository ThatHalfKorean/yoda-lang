PARSER_BEGIN(Parser)

package edu.lmu.cs.xlg.yoda.syntax;

import java.util.List;
import java.util.ArrayList;
import java.io.Reader;
import edu.lmu.cs.xlg.util.Log;
import edu.lmu.cs.xlg.yoda.entities.*;

public class Parser {
    /**
     * Returns the result of parsing the Yoda program on the given Reader.
     */
    public Script parse(Log log) {
        try {
            return SCRIPT();
        } catch (TokenMgrError e) {
            log.exception(e);
            return null;
        } catch (ParseException e) {
            log.exception(e);
            return null;
        }
    }
}

PARSER_END(Parser)

SKIP: { " " | "\t"
    | <"<(-_-)>" (~["\n","\r"])* ("\n"|"\r")>
}

SKIP : {
    "<(-.-)>" : WithinComment
}

<WithinComment> SKIP :
{
    "<(-.-)>" : DEFAULT
}

<WithinComment> MORE :
{
    <~[]>
}

TOKEN: {
    "(" | ")" | "{" | "}" | "+" | "*" | ":=" | "|" | "&" | "," | ":" | "."
    | <IF: ("if")>
    | <TO: ("to")>
    | <BY: ("by")>
    | <AND: ("and")>
    | <HMM: ("hmm")>
    | <HMMQ: ("hmm?")>
    | <IS: ("is?")>
    | <ELSE: ("else")>
    | <FROM: ("from")>
    | <DOES: ("does")>
    | <RUNS: ("runs")>
    | <WHILE: ("while")>
    | <BEGIN: ("begin")>
    | <BEGINS: ("begins")>
    | <GIVEN: ("given")>
    | <GIVES: ("gives")>
    | <GET: ("get")>
    | <TIMES: ("times")>
    | <BECOME: ("become")>
    | <BECOMES: ("becomes")>
    | <NOTHING: ("nothing")>
    | <THROUGH: ("through")>
    | <AS: ("as")>
    | <TRAINING: ("training")>
    | <MUST: ("must")>
    | <BE: ("be")>
    | <YOU: ("you")>
    | <PRINT: ("print")>
    | <GIVEBACK: ("give back")>
    | <ID: ((["a"-"z"] | ["A"-"Z"])+(["-"] | ["_"] | ["a"-"z"] | ["A"-"Z"] | ["0"-"9"])*)>
    | <NUMLIT: (("0x" | "0b" | "0o")? (["0"-"9"])+("."(["0"-"9"])*)?)>
    | <STRLIT: ("\"" (~["\""] | ("\\\""))* "\"") >
    | <BR: ("\n" | "\r" | "\r\n" )>

}


Script SCRIPT(): {
    List<Statement> statements = new ArrayList<Statement>();
    Statement s;
}
{
    (<BR>)*
    (s = STMT() {statements.add(s);})+
    <EOF>
    {return new Script(statements);}
}

Statement STMT(): {
    Statement s;
}
{
     (LOOKAHEAD(BLOCK() <WHILE>) s = WHILELOOP()
   | LOOKAHEAD(BLOCK() <AS>) s = FORLOOP()
   | LOOKAHEAD(BLOCK() <IF>) s = CONDITIONAL()
   | LOOKAHEAD(BLOCK() EXP()) s = TIMESLOOP()
   | LOOKAHEAD(BLOCK() <GIVEN> PARAMS() "," <ID> <DOES>) s = PROCDEC()
   | LOOKAHEAD(BLOCK() <GIVEN> PARAMS() "," <ID> <GIVES>) s = FUNDEC()
   | LOOKAHEAD(BLOCK() <GIVEN> ARGS()) s = ANONFUN()
   | LOOKAHEAD(EXP() <YOU> <PRINT>) s = PRINTSTMT()
   | LOOKAHEAD(EXP() "," <ID> <MUST> <BE>) s = CONSTDEC()
   | LOOKAHEAD(<FROM> | (EXP() (<AND> EXP())*  "," <ID> ( <AND> <ID>)* (<BEGIN> | <BEGINS>))) s = VARDEC()
   | LOOKAHEAD(EXP() (<AND> EXP())* "," <ID> ( <AND> <ID>)* (<BECOME> | <BECOMES>)) s = ASSIGNMENT()
   | LOOKAHEAD((<ID> ".") | ("(" ARGS() ")" <ID>)) s = FUNCALL()
   | LOOKAHEAD(<GIVEBACK>) s = RETURNSTMT()
   | LOOKAHEAD(FUNCALL()) s = PROCCALL()
)// TODO: expression is not a statement
   //| s = EXP())
   ((<BR>)+ | <EOF>)
   {return s;}
}

DecStatement VARDEC(): {
    List<String> tokens = new ArrayList<String>();
    List<Variable> variables = new ArrayList<Variable>();
    Token t;
    List<Expression> exps = new ArrayList<Expression>();
    Expression e;
    boolean constant = false;
}
{
    ((e = EXP() ){exps.add(e);} (<AND> (e = EXP()) {exps.add(e);} )* "," (t = <ID>) {tokens.add(t.image);}
        ( <AND>  (t = <ID>) {tokens.add(t.image);})*  (<BEGIN> | <BEGINS>))
        | (<FROM> EXP() "," (t = <ID>) {tokens.add(t.image);}  <BEGINS>)
    // TODO: Must account for multiple declarations.
    {for(int i = 0; i < tokens.size(); i++){
        variables.add(new Variable(tokens.get(i), exps.get(i), constant));
    }
    return new DecStatement(variables);}
}

Variable CONSTDEC(): {
    Token t;
    Expression e;
    boolean constant = true;
}
{
    ((e = EXP() ) "," (t = <ID>)  <MUST>  <BE>)
    {return new Variable(t.image, e, constant);}
}

Procedure PROCDEC(): {
    Token t;
    Block b;
    List<Variable> params = new ArrayList<Variable>();
}
{
    ((b = BLOCK()) <GIVEN> (PARAMS(params)) ","  (t = <ID>)  <DOES>)
    {return new Procedure(t.image, params, b);}
}

Function FUNDEC(): {
    Token t;
    Block b;
    List<Variable> params = new ArrayList<Variable>();
}
{
    ((b = BLOCK()) <GIVEN> (PARAMS(params)) ","  (t = <ID>)  <GIVES>)
    {return new Function(t.image, params, b);}
}
void PARAMS(List<Variable> params): {
    Token t;
}
{
    (<NOTHING> | (t = <ID> {params.add(new Variable(t.image, null, false));}
     (  <AND>  t = <ID> {params.add(new Variable(t.image, null, false));})*))
}

Statement ASSIGNMENT(): {
    List<String> tokens = new ArrayList<String>();
    List<Expression> targets = new ArrayList<Expression>();
    List<Expression> sources = new ArrayList<Expression>();
    Token t;
    Expression e;
    String op = null;
    IdentifierExpression i;
}
{
    (( op = INCOP() t = <ID>
    {i = new IdentifierExpression(t.image);
        e = new UnaryExpression(op, i);
        targets.add(i);
        sources.add(e);} )
    | (op = UPDATE() t = <ID> e = EXP5()
    {i = new IdentifierExpression(t.image);
        targets.add(i);
        sources.add(e);})
    | (e = EXP(){sources.add(e);} (<AND> e = EXP() {sources.add(e);})*
        ","  t = <ID> {i = new IdentifierExpression(t.image);
        targets.add(i);}(  <AND> t = <ID> {targets.add(i);})*  (<BECOME> | <BECOMES>)))
    {return new AssignmentStatement(i, e);}
}

Statement PRINTSTMT(): {
    Expression e;
}
{
    (e = EXP() <YOU> <PRINT>)
    {return new PrintStatement(e);}
}

Statement RETURNSTMT(): {
    Expression e = null;
    Function f = null;
}
{
    (<GIVEBACK> ( f = ANONFUN() | e = EXP()) <YOU>  <MUST>)
    {
        if(f == null) {
            return new ReturnStatement(e);
        } else {            return f;
        }
    }
}

Statement CONDITIONAL(): {
    List<ConditionalStatement.Arm> arms = new ArrayList<ConditionalStatement.Arm>();
    Expression e;
    Block b;
    Block elseBlock = null;
}
{
    (b = BLOCK() <IF> "(" e = EXP()    {arms.add(new ConditionalStatement.Arm(e, b));} ")"
    (LOOKAHEAD((<BR>)+ <ELSE> BLOCK() <IF>) (<BR>)+ <ELSE> b = BLOCK() <IF> "(" e = EXP() ")"
    {arms.add(new ConditionalStatement.Arm(e, b));})*
    (LOOKAHEAD((<BR>)+ <ELSE>)(<BR>)+ <ELSE> elseBlock = BLOCK() )?)

    {return new ConditionalStatement(arms, elseBlock);}
}

Statement TIMESLOOP(): {
    Block b;
    Expression e;
}
{
    (b = BLOCK() e = EXP() <TIMES>)
    {return new TimesLoop(e, b);}
}

Statement FORLOOP(): {
    Block b;
    Token t;
    Expression condition = null;
    Expression step = new NumberLiteral("1");
    Range r = null;
}
{
    b = BLOCK() <AS>  <THROUGH> (LOOKAHEAD( (<NUMLIT> | <ID> | FUNCALL() ) <TO>) r = RANGE()
                                             | condition = EXP5() ) (<BY> step = EXP5())? t = <ID>  <RUNS>
    {
        if(condition == null) {            return new RangeLoop(new Variable(t.image), r, step, b);
        } else {
            return new ConditionalLoop(new Variable(t.image), condition, step, b);        }
    }
}

Statement WHILELOOP(): {
    Block b;
    Expression e;
}
{
    b = BLOCK() <WHILE> e = EXP()
    {return new WhileLoop(e, b);}
}

Statement PROCCALL(): {
    Statement s;
}
{
    s = FUNCALL()
    {return s;}
}

Block BLOCK(): {
    List<Statement> statements = new ArrayList<Statement>();
    Statement s;
}
{
    ("{" (<BR>)* (s = STMT() {statements.add(s);})
        ((<BR>)+ (s = STMT(){statements.add(s);})?)* (<BR>)*"}")
    {return new Block(statements);}
}

Expression EXP(): {
    Expression e1;
    Expression e2;
}
{
    e1 =  EXP1() ("|" e2 = EXP1(){e1 = new BinaryExpression(e1, "|", e2);} )*
    {return e1;}
}
Expression EXP1(): {
    Expression e1;
    Expression e2;
}
{
    e1 = EXP2() ("&" e2 = EXP2() {e1 = new BinaryExpression(e1, "&", e2);})*
    {return e1;}
}
Expression EXP2(): {
    String op;
    Expression e1;
    Expression e2;
}
{
    (op = RELOP() e1 = EXP3() e2 = EXP3() <IS> {e1 = new BinaryExpression(e1, op, e2);} )
   | (op = ARITHOP() e1 = EXP3() (e2 = EXP3(){e1 = new BinaryExpression(e1, op, e2);})+ )
   | e1 = EXP3()
   {return e1;}
}

Expression EXP3(): {
    String op = null;
    Expression e;
}
{
    (op = UNARYOP()  e = EXP4() )  | e = EXP4()
    {return op == null ? e : new UnaryExpression(op, e);}
}
Expression EXP4(): {
    Expression condition;
    Expression t = null;
    Expression f = null;
}
{
/* TODO: Why does this have an assignment in there? */
    //( condition = EXP5() (<HMMQ> (t = EXP5() | t = ASSIGNMENT()) <HMM> (f = EXP5() | f = ASSIGNMENT()) )?)
    ( condition = EXP5() (<HMMQ> (t = EXP5()) <HMM> (f = EXP5()) )?)
    {return new TernaryExpression(condition, t, f);}
}
Expression EXP5(): {
    Expression e;
    Token t;
}
{
    (e = ARRAY()
   | e = LIT()
   | LOOKAHEAD("{" (<BR>)* (":" | "}")) e = OBJECT()
/* TODO: funcall needs to be an expression here? */
//   | LOOKAHEAD((<ID> ".")? "("ARGS()")") FUNCALL()
   | t = <ID> {e = new IdentifierExpression(t.image);}
   | "(" e = EXP() ")")
    {return e;}
}

Literal LIT(): {
    Token t;
}{
  t = <NUMLIT>  {return new NumberLiteral(t.image);}  |
  t = <STRLIT>
  {return new StringLiteral(t.image);}
}

ArrayConstructor ARRAY():{
    Expression e;
    List<Expression> es = new ArrayList<Expression>();}
{
    ("[" ( (<BR>)? e = EXP() {es.add(e);} ("," (<BR>)? e = EXP() {es.add(e);})* (<BR>)?)* "]")
    {return new ArrayConstructor(es);}
}
ObjectExpression OBJECT(): {
    ObjectExpression o = new ObjectExpression();
    Token t;
    Expression e = null;
    Function f = null;
}
{ "{" (<BR>)* (":" t = <ID> ( f = ANONFUN() | e = EXP5())
    ( "," (<BR>)* ":" <ID> (ANONFUN() | EXP5()))* (<BR>)* )? (<BR>)* "}" (<TO>  <BE>  <ID>)? ","  (<ID> )? <TRAINING>  <BEGINS>
    {return o;}
}

Function ANONFUN(): {
    Block b;
    List<Variable> params = new ArrayList<Variable>();
}
{
    b = BLOCK() <GIVEN> PARAMS(params)
    {return new Function(null, params, b);}
}
FunctionCall FUNCALL(): {
    Token functionName = null;
    List<Expression> args = new ArrayList<Expression>();
    Token objectName = null;
    Function f = null;
}
{
    (objectName = <ID>".")?"("args = ARGS()")"(functionName = <ID> | f = ANONFUN())
    {
        if(functionName == null) {
            return f;
        } else {
            return new CallStatement(functionName.image, args, objectName.image);
        }    }
}
String RELOP(): {
    Token s;
}

{   s = "<"
    | s = "<="
    | s = "="
    | s = "!="
    | s = ">="
    | s = ">"
    {return s.image;}
}
String ARITHOP(): {
    Token s;
    String update;
}
{
    s = "*"
    | s = "/"
    | s = "+"
    | s = "-"
    | s = "%"
    | s = "^"
    | update = UPDATE() {return update;}
    {return s.image;}
}

String UNARYOP(): {
    Token t;
}
{
    t = "!"    {return t.image;}}

String INCOP(): {
    Token s;
}
{
    s = "++"
    | s = "--"
    {return s.image;}
}

String UPDATE(): {
    Token s;
}
{
    s = "+="
    | s = "-="
    {return s.image;}
}

List<Expression> ARGS(): {
    List<Expression> args = new ArrayList<Expression>();
}
{
    (ARGS1(args) ("," ARGS1(args))*)?
    {return args;}
}
void ARGS1(List<Expression> args): {
}
{
   LOOKAHEAD(BLOCK() <GIVEN> PARAMS() "," <ID> <DOES>) PROCDEC()
   | LOOKAHEAD(BLOCK() <GIVEN> PARAMS() "," <ID> <GIVES>) FUNDEC()
   | LOOKAHEAD(BLOCK() <GIVEN> PARAMS()) ANONFUN()
   | LOOKAHEAD((<ID>".")? "("ARGS()")") FUNCALL()
   | EXP5()
}
Range RANGE(): {
    Expression l = null;
    Expression h = null;
    Token t;
}
{
    (t = <NUMLIT> {l = new NumberLiteral(t.image);}
    |t = <ID> {l = new IdentifierExpression(t.image);}
    | FUNCALL())
    <TO> (t = <NUMLIT> {h = new NumberLiteral(t.image);}
    | t = <ID> {h = new IdentifierExpression(t.image);}
    | FUNCALL())    {return new Range(l, h);}
}
